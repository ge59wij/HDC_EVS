import torch
import torchhd
from DAT_loadergrasp import GRASP_DAT_EventLoader
import os
import matplotlib.pyplot as plt
import numpy as np
class GraspHDseedEncoder:
    def __init__(self, height, width, dims, time_subwindow, k, device):
        self.height = height
        self.width = width
        self.dims = dims
        self.time_subwindow = time_subwindow
        self.k = k  # Window size
        self.device = device if device else torch.device("cpu")  # Use provided device or default to CPU


        '''6.11 Seed hvs Generation'''

        #1. Polarity random bipolar hvs (h I + = - h I-) :
        self.H_I_plus = torchhd.random(1, dims, "MAP", device=self.device).squeeze(0)
        self.H_I_minus = - self.H_I_plus

        #2. 2D Position HVS, kxk frame approach: "assures thatthe resulting 2D position HV preserves the spatial correlation between events in the scene."
        self.corner_hvs = self._generate_corner_hvs()

        # 3. Timestamp Hypervectors: explained in Notion#wrong too random
        #  time hypervectors will be generated on-demand#wrong
    def _generate_corner_hvs(self):
        """Generates corner hypervectors ONCE."""
        num_rows = self.height // self.k + 1
        num_cols = self.width // self.k + 1
        return torchhd.random(num_rows * num_cols, self.dims, "MAP", device=self.device).reshape(num_rows, num_cols, self.dims)

    def _generate_time_hvs(self, last_timestamp):
        """Generates timestamp hypervectors dynamically based on the actual last timestamp in the dataset."""
        # Ensure last_timestamp is a float32 (from your data type table)
        if not isinstance(last_timestamp, (float, np.float32)):
            last_timestamp = float(last_timestamp)

        # Compute the number of time bins and cast it to an integer
        num_time_bins = int((last_timestamp // self.time_subwindow) + 1)

        # Debugging prints
        print(
            f"last_timestamp: {last_timestamp}, self.time_subwindow: {self.time_subwindow}, num_time_bins: {num_time_bins}")

        # Ensure dimensions are correct
        assert isinstance(num_time_bins, int), f"num_time_bins is not an int: {num_time_bins}"
        assert isinstance(self.dims, int), f"self.dims is not an int: {self.dims}"

        return torchhd.random(num_time_bins, self.dims, "MAP", device=self.device)

    def get_position_hv(self, x, y):
        """Generates timestamp hypervectors dynamically based on the actual last timestamp in the dataset."""
        ##now: only generate (height//k + 1, width//k + 1) hypervectors instead of (height, width): On-Demand Generation
        # aka interpolates between corner hypervectors only when needed, rather than storing everything in advance for each pixel => revise

        """##Dynamically### generates a position hypervector for pixel (x, y) using interpolation.
        ## Corner pixels in each block get randomly assigned hvs, Intermediate pixels are generated by interpolating between corner hvs
        #=> ensures that neighboring pixels have correlated hvs, preserving spatial smoothness
        #####experiment with k, not sure about their grid size, but they used k=2. their grid should be 200x250."""
        #1) Frame Division, paper page 9. Determine the block (i, j) where the pixel is located.
        # 1) Compute block indices (ensure within bounds)
        i = min(x // self.k, self.corner_hvs.shape[0] - 1)  # Clamp to valid range
        j = min(y // self.k, self.corner_hvs.shape[1] - 1)  # Clamp to valid range

        # 2) Get neighboring corner hypervectors
        i_next = min(i + 1, self.corner_hvs.shape[0] - 1)
        j_next = min(j + 1, self.corner_hvs.shape[1] - 1)

        # 3) get the four corner hypervectors
        P00 = self.corner_hvs[i, j]
        P01 = self.corner_hvs[i, j_next]
        P10 = self.corner_hvs[i_next, j]
        P11 = self.corner_hvs[i_next, j_next]


        #4) Intermediate Hvs Interpolation: based on pixel's position within the block
        # Interpolating for intermediate pixels: pixels in same ith window, get a HV by combining dims from 4 corners hvs
        ####### distance from corner ~ proportion of dim taken from each corner!
        '''#####example for k=2, Pixel corners: P00, P02 P20 P22
                
            2 P20 P21 P22
            1 P10 P11 P12
            0 P00 P01 P02
               0   1  2  
               
            for P01: 50% from P00 and 50% P02 (window edge). right and left pixels.
            for P11:center: 25%% from each corner.

            '''
        # Compute interpolation factors
        alpha_x = (x % self.k) / (self.k - 1) if self.k > 1 else 0.5
        alpha_y = (y % self.k) / (self.k - 1) if self.k > 1 else 0.5

        interpolated_hv = (
            (1 - alpha_x) * (1 - alpha_y) * P00 +
            alpha_x * (1 - alpha_y) * P10 +
            (1 - alpha_x) * alpha_y * P01 +
            alpha_x * alpha_y * P11
        )
        return interpolated_hv

    def get_time_hv(self, time, time_hvs):
        """Dynamically generates a timestamp hypervector for a given time value using interpolation."""
        # Compute the indices and ensure they are integers
        i = int(time // self.time_subwindow)  # Integer division for index
        i_next = min(i + 1, time_hvs.shape[0] - 1)  # Ensure i_next is within bounds

        # Debugging print
        #print(f"time: {time}, i: {i}, i_next: {i_next}, time_hvs shape: {time_hvs.shape}")

        # Get two closest timestamp hypervectors
        T_i = time_hvs[i]
        T_next = time_hvs[i_next]

        # Compute interpolation factor alpha
        alpha_t = (time % self.time_subwindow) / self.time_subwindow if self.time_subwindow > 1 else 0.5

        # Interpolate between the two hypervectors
        return (1 - alpha_t) * T_i + alpha_t * T_next


def interpolate_time_hv(T_start, T_end, alpha):
    """Interpolate between two hvs based on alpha : position in time sub-window."""
    dims = T_start.shape[0]
    num_from_start = int((1 - alpha) * dims)
    return torch.cat((T_start[:num_from_start], T_end[num_from_start:]), dim=0)




