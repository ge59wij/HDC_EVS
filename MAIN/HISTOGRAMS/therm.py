import torch
import torchhd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def generate_linear_mapping_hvs(size, dims, device):
    """
    Generates position HVs using the **linear mapping** method.
    - The first position is assigned a random HV.
    - Each subsequent position HV is generated by flipping D/2(L-1) bits from the previous HV.
    """
    levels = size  # Number of discrete positions
    flip_bits = dims // (4 * (levels - 1))  # Number of bits to flip per level
    base_hv = torchhd.random(1, dims, "MAP", device=device).squeeze(0)
    hvs = [base_hv.clone()]

    for i in range(1, levels):
        new_hv = hvs[-1].clone()
        flip_indices = torch.randperm(dims)[:flip_bits]  # Randomly select bits to flip
        new_hv[flip_indices] = -new_hv[flip_indices]  # Flip selected bits
        hvs.append(new_hv)

    return torch.stack(hvs)


def plot_similarity_heatmap(hvs, title):
    """Plots a heatmap of cosine similarities between hypervectors."""
    similarity_matrix = torchhd.cosine_similarity(hvs, hvs).cpu().numpy()

    plt.figure(figsize=(10, 8))
    sns.heatmap(similarity_matrix, annot=False, fmt=".2f", cmap="coolwarm",
                cbar=True, square=True, linewidths=0.5)
    plt.title(title)
    plt.xlabel("Position Index")
    plt.ylabel("Position Index")
    plt.show()


if __name__ == "__main__":
    device = "cpu"
    dims = 10000  # Dimensionality of hypervectors
    width = 160  # Example: Width of the image grid
    height = 120  # Example: Height of the image grid

    print("Generating Linear Mapping HVs for X positions...")
    hv_x = generate_linear_mapping_hvs(width, dims, device)

    print("Generating Linear Mapping HVs for Y positions...")
    hv_y = generate_linear_mapping_hvs(height, dims, device)

    # **Bind X and Y HVs to simulate final pixel representations**
    hv_grid = torch.zeros((height, width, dims), device=device)
    for x in range(width):
        for y in range(height):
            hv_grid[y, x] = torchhd.bind(hv_x[x], hv_y[y])

    # **Choose a pixel (center pixel for now)**
    chosen_x, chosen_y = 70, 50 #width // 2, height // 2
    chosen_hv = hv_grid[chosen_y, chosen_x]

    # **Compute cosine similarity with all other pixels**
    hv_flattened = hv_grid.view(-1, dims)  # Reshape to (height * width, dims)
    similarity_matrix = torchhd.cosine_similarity(chosen_hv, hv_flattened).view(height, width).cpu().numpy()

    # **Plot similarity heatmap**
    plt.figure(figsize=(12, 10))
    sns.heatmap(similarity_matrix, annot=False, fmt=".2f", cmap="coolwarm",
                cbar=True, square=False, linewidths=0.5)
    plt.title(f"Cosine Similarity of Pixel ({chosen_x}, {chosen_y}) with Others")
    plt.xlabel("X Position")
    plt.ylabel("Y Position")
    plt.show()
